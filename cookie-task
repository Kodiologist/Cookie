#!/usr/bin/env python
# encoding: UTF-8

from sys import argv
from math import sqrt
from re import match
from random import sample, choice
from datetime import datetime
from psychopy.monitors import Monitor
from psychopy.gui import Dlg
from psychopy.core import wait
from psychopy.event import Mouse, getKeys, clearEvents
from psychopy.visual import \
    Window, ShapeStim, Circle, TextStim, SimpleImageStim, RatingScale
import pyglet
import json
from socket import gethostname
from cookie_gui import DlgSansCancel

output_path_prefix = argv[1] if len(argv) >= 2 else "results"
cake_image_path = argv[2] if len(argv) >= 3 else "cake.png"
splotch_path_fmt = argv[3] if len(argv) >= 4 else "splotches/%d.png"
commit_path = argv[4] if len(argv) >= 5 else "commit.txt"

test_splotches = [
    22, 3, 11,   14, 28, 23,   29, 12, 1,   6, 15, 19,   7, 30]
example_splotch = 20

likert_scale_max = 9
button_radius = .1

# ------------------------------------------------------------
# Helper functions and classes
# ------------------------------------------------------------

def shuffled(l): return sample(l, len(l))

def staggered(l):
    'staggered([1, 2, 3]) → [(1, 2), (2, 3), (3, None)]'
    return zip(l, list(l[1:]) + [None])

def tuplecat(a, b): return (
  b if a is () else
  a if b is () else
 (a if isinstance(a, tuple) else (a,)) +
 (b if isinstance(b, tuple) else (b,)))

data = dict()
def save(key, value):
    """Set a value in data with Perl-style autovivification, so
    save(('times', 3, 'orange'), 'x') is like
    data['times'][3]['orange'] = 'x' but works even if the
    intermediate data structures don't exist yet."""
    key = tuplecat(tuple(dkey_prefix.p), key)
    if isinstance(key, tuple):
        seq = data
        for k, next_k in staggered(key):
            newobj = (
                 value if next_k is None else
                 [] if isinstance(next_k, int) else
                 {}) # if isinstance(next_k, str)
            if isinstance(seq, dict):
                if k not in seq:
                    seq[k] = newobj
            elif isinstance(seq, list):
                if len(seq) - 1 < k:
                    # The list is too short. Pad it out with Nones.
                    seq[len(seq):] = (k + 1 - len(seq)) * [None]
                if seq[k] is None:
                    seq[k] = newobj
            else: raise KeyError
            seq = seq[k]
    elif isinstance(key, str):
        data[key] = value
    else: raise KeyError

class dkey_prefix:
    p = ()
    def __init__(self, x):
        self.x = x if isinstance(x, tuple) else (x,)
    def __enter__(self):
        dkey_prefix.p = tuplecat(self.x, dkey_prefix.p)
    def __exit__(self, _1, _2, _3): 
        dkey_prefix.p = dkey_prefix.p[len(self.x):]

save(('sys', 'hostname'), gethostname())
with open(commit_path, "r") as f:
    save('commit', f.readline().strip())

class timestamps:
   def __init__(self, dkey):
       self.dkey = dkey
   def timestamp(self, i):
       with dkey_prefix('times'): save(tuplecat(self.dkey, i),
           datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S.%f"))
   def __enter__(self):
       self.timestamp(0)
   def __exit__(self, _1, _2, _3):
       self.timestamp(1)

# ------------------------------------------------------------
# Stimuli
# ------------------------------------------------------------

pyglet_screen = pyglet.window.get_platform().get_default_display().get_default_screen()
screen_width, screen_height = pyglet_screen.width, pyglet_screen.height
save(('sys', 'resolution'), (screen_width, screen_height));
approx_dialog_box_width = 200
win = Window((screen_width, screen_height),
    monitor = 'testMonitor',
    winType = 'pyglet', fullscr = False,
    units = 'norm', color = 'white')
mouse = Mouse(win = win)

splotch = SimpleImageStim(win, pos = (0, 125),
    image = splotch_path_fmt % (example_splotch,))

class showing:
    '''"with showing(foo, bar): …" ensures that foo and bar are
    implicitly drawn on each call to draw().'''
    implicitly_draw = []
    def __init__(self, *stimuli):
        self.stimuli = stimuli
    def __enter__(self):
        for s in self.stimuli: showing.implicitly_draw.append(s)
    def __exit__(self, _1, _2, _3):
        for s in self.stimuli: showing.implicitly_draw.remove(s)
def draw(*stimuli):
   for s in stimuli: s.draw()
   for s in showing.implicitly_draw: s.draw()
   win.flip()

def text(x, y, string, hAlign = 'center', vAlign = 'center', wrap = None):
    return TextStim(win,
        text = string, pos = (x, y), color = 'black',
        height = .075, alignHoriz = hAlign, alignVert = vAlign,
        wrapWidth = wrap)

def rating_scale(**a): return RatingScale(win,
    textColor = 'black', lineColor = 'black',
    markerStyle = 'circle', markerColor = 'darkgreen',
    stretchHoriz = 1.75,
    showValue = False, allowSkip = False, showScale = False,
    escapeKeys = ['escape'], singleClick = True, showAccept = False,
    **a)

def likert_scale(lo, hi, x = 0, y = -.7): return rating_scale(
    low = 1, lowAnchorText = lo,
    high = likert_scale_max, highAnchorText = hi,
    pos = (x, y))

def probability_scale(x, y, fixed = None):
    args = dict(
        low = 0, high = 1, pos = [x, y],
        lowAnchorText = 'impossible', highAnchorText = 'certain')
    if fixed is not None: args['customMarker'] = text(0, 0, "")
    rs = rating_scale(**args)
    if fixed is not None:
      # And now we abuse the object system to get rs.draw() to
      # draw a tick mark along with the scale.
        leftmost = min([v[0] for v in rs.line.vertices])
        scale_width = max([v[0] for v in rs.line.vertices]) - leftmost
        tick_x = fixed * scale_width + leftmost
        rs.tick = ShapeStim(win,
            vertices = ((tick_x, y + .05), (tick_x, y - .05)),
            lineColor = "green", lineWidth = 3)
        real_draw = RatingScale.draw
        def my_draw():
            real_draw(rs)
            rs.tick.draw()
        rs.draw = my_draw
    rs.precision = 1000
      # The constructor doesn't allow precisions above 100.
    return rs

class Button:

    def __init__(self, x, y, string):
        self.x, self.y, self.string, = x, y, string
        self.circle = Circle(win,
            button_radius, pos = (x, y),
            lineColor = 'black', lineWidth = 3, edges = 64,
            fillColor = 'lightgray')
        self.text = text(x, y, string)
        self.was_pressed = False

    def draw(self):
        self.circle.draw()
        self.text.draw()

    def inside(self, (x, y)): return (
        sqrt((self.x - x)*(self.x - x) + (self.y - y)*(self.y - y))
        <= button_radius)

    def activated(self):
        if self.was_pressed or (
                any(mouse.getPressed()) and
                self.inside(mouse.getPos())):
            self.was_pressed = True
            return True
        return False

def scale_screen(dkey, *stimuli):
    """Display some stimuli (including at least one scale) until
    the subject has responded to all the scales."""
    scales = filter(lambda x: isinstance(x, RatingScale), stimuli)
    clearEvents()
    with timestamps(dkey):
        while any([x.noResponse for x in scales]): draw(*stimuli)
    wait(.25)
      # To make the transition less jarring.
    rs = [x.getRating() for x in scales]
    save(dkey, rs[0] if len(rs) == 1 else rs)

def button_screen(dkey, *stimuli):
    """Display some stimuli (including at least one button) until
    the subject presses a button."""
    buttons = filter(lambda x: isinstance(x, Button), stimuli)
    with timestamps(dkey):
        while all([not x.activated() for x in buttons]):
            if getKeys(['escape']): exit()
            clearEvents()
            draw(*stimuli)
    if len(buttons) > 1:
      # No sense in saving the value of the button if there's only
      # one.
        save(dkey, filter(lambda x: x.activated(), buttons)[0].string)
    wait(.25)

def get_amount(dkey, string):
    "Ask for a monetary amount with the given prompt."
    draw(
        text(0, .8, string, vAlign = 'top'))
    with timestamps(dkey):
        trying_again = False
        while True:
            dialog = DlgSansCancel(
                title = 'Entry',
                pos = (screen_width/2 - approx_dialog_box_width, .85 * screen_height))
            dialog.addText(' ' * 45)
            dialog.addField('Amount:')
            dialog.addText(
                 'Invalid dollar amount; please try again.'
                 if trying_again else '')
            dialog.show()
            amount = dialog.data[0]
            mo = match(r'\s*\$?\s*(\d+(?:\.\d\d?)?)\s*$', amount)
            if mo:
                save(dkey, mo.groups(1)[0])
                break
            else:
                trying_again = True
    wait(.25)

def wait_screen(time_to_wait, *stimuli):
    'Display some stimuli for a given amount of time.'
    draw(*stimuli)
    wait(time_to_wait)

# ------------------------------------------------------------
# Get the subject number
# ------------------------------------------------------------

dialog = Dlg(title = 'Decision-Making')
dialog.addText('')
dialog.addField('Subject Number:', 0)
dialog.addText('')
dialog.show()

if not dialog.OK: exit()

subject = int(dialog.data[0])
save('subject', subject)

# ------------------------------------------------------------
# Explain the gamble outcomes
# ------------------------------------------------------------

def instructions(dkey, string): button_screen(dkey,
    text(0, .8, string, vAlign = 'top'),
    Button(0, -.5, 'Next'))

def rating(dkey, string, lo, hi): return scale_screen(dkey,
    text(0, .3, string),
    likert_scale(lo, hi, y = -.3))

with dkey_prefix('outcomes'):

    instructions('first_page', 'In this task, you will be asked to evaluate several gambles. These gambles will be hypothetical, but try your best to imagine what you would choose if you were really offered them.\n\nEach gamble has three possible outcomes: good, neutral, and bad.')

    instructions('neutral_description', 'If you get the neutral outcome, nothing happens.')

    instructions(('cake', 'description'), 'If you get the good outcome, you win a generous piece of chocolate cake!')

    if choice((False, True)):
        save(('cake', 'showed_picture'), True)
        button_screen('cake_picture',
            text(0, .8, "Here's what the cake looks like:", vAlign = "top"),
            SimpleImageStim(win, image = cake_image_path),
            Button(0, -.8, 'Next'))
    else:
        save(('cake', 'showed_picture'), False)

    rating(('cake', 'appeal'),
        'How appealing do you find this cake outcome?',
        'totally unappealing', 'very appealing')

    get_amount(('cake', 'wtp'), "Now, suppose you played the following game: you would pick an amount of money (say, $5.50), and then the computer would randomly select a price less than $10. If the randomly selected price was less than or equal to the amount of money you picked, you would be obliged to buy the piece of cake for the price. But if the price was greater than the amount you picked, you wouldn't be able to buy the cake even if you wanted to.\n\nWhat amount would you choose?")

    instructions(('arithmetic', 'description'), "If you get the bad outcome, we'll ask you to solve a set of long-division problems, which we expect will take about half an hour.")

    rating(('arithmetic', 'appeal'),
        'How appealing do you find this arithmetic outcome?',
        'totally unappealing', 'very appealing')

    get_amount(('arithmetic', 'wtp'), 'Suppose you played this game: as before, you would pick an amount of money, and then the computer would randomly select a price less than $10. This time, if the randomly selected price was less than or equal to the amount of money you picked, you would have to pay the price without getting anything in return. On the other hand, if the price was greater than the amount you picked, you would have to do the long-division problems.\n\nWhat amount would you choose?')

    rating('overall_appeal',
        'How would you feel if you got neither the good outcome nor the bad outcome?',
        'very disappointed', 'very relieved')

    button_screen('would_take_both',
        text(0, .3, 'If you were offered the cake in exchange for doing the division problems, would you take it?'),
        Button(-.25, -.3, 'Yes'),
        Button(.25, -.3, 'No'))

# ------------------------------------------------------------
# Administer a brief measure of temporal discounting
# ------------------------------------------------------------

with dkey_prefix('discount'):

    get_amount('week', "Now suppose you've won a raffle with a cash prize. At your option, you may receive $20 right now or a larger amount of money one week in the future. What is the smallest amount of money that would have to be offered at this future time in order for you to be indifferent between the two options, $20 immediately and the larger amount a week from now?")

    get_amount('month', 'What if the delay was one month instead? Again, what is the smallest amount of money that would have to be offered at this future time in order for you to be indifferent between the two options, $20 immediately and the larger amount a month from now?')

# ------------------------------------------------------------
# Explain the stimuli, with examples
# ------------------------------------------------------------

with showing(splotch):
    def instructions(dkey, string, *stimuli): button_screen(dkey,
        text(-.95, .75, string, hAlign = 'left', vAlign = 'top', wrap = .5),
        Button(0, -.8, 'Next'),
        *stimuli)

    instructions(('picture_explan', 0), "Each of the gambles you'll be asked to evaluate will be presented as a picture like this.")

    instructions(('picture_explan', 1), 'Each color represents the probability of a different outcome. Yellow represents the good outcome (cake), black represents the netural outcome (nothing), and blue represents the bad outcome (arithmetic). Each probability is expressed as area.')

    instructions(('picture_explan', 2), "For example, one-twentieth of this image's area is yellow. Thus, the probability of getting the good outcome from this gamble is 1 out of 20.")

    instructions('mark_example', "You'll provide your judgments of probability using a linear scale like this. In this case, if you were asked the probability of the good outcome, you would click on the point marked by the green line.",
        probability_scale(.3, -.5, fixed = .05))

button_screen('before_gambles',
    text(0, .8, 'Now for the first gamble.', vAlign = 'top'),
    Button(0, -.5, 'Next'))

# ------------------------------------------------------------
# Have the subject evaluate some gambles
# ------------------------------------------------------------

with showing(splotch):
    for trial, splotch_num in enumerate(shuffled(test_splotches)):
        splotch.setImage(splotch_path_fmt % (splotch_num,))
        with dkey_prefix(('gambles', trial)):
            save('splotch', splotch_num)
            scale_screen('probs',
                text(-.95, -.4, u'How likely is…', 'left'),
                text(-.95, -.5, u'…the good outcome?', 'left'),
                probability_scale(.3, -.5),
                text(-.95, -.75, u'…the bad outcome?', 'left'),
                probability_scale(.3, -.75))
            scale_screen('appeal',
                text(0, -.5, 'How appealing do you find this gamble?'),
                likert_scale('totally unappealing', 'very appealing'))
            button_screen('choice',
                text(0, -.5, 'If you were offered this gamble, would you take it?'),
                Button(-.25, -.75, 'Yes'),
                Button(.25, -.75, 'No'))

# ------------------------------------------------------------
# Done!
# ------------------------------------------------------------

with open("%s%d.json" % (output_path_prefix, subject), "w") as out:
    json.dump(data, out, sort_keys = True, indent = 2)

wait_screen(1,
    text(0, 0, 'Done!\n\nPlease let the experimenter know you are done.'))
