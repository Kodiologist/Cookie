#!/usr/bin/env python
# encoding: UTF-8
VERSION = 'undeployed'

from sys import argv
from math import sqrt
from itertools import permutations
from re import match, search
from random import sample, choice, randint
from datetime import datetime
from types import MethodType
from psychopy.monitors import Monitor
from psychopy.gui import Dlg
from psychopy.core import wait
from psychopy.event import Mouse, getKeys, clearEvents
from psychopy.visual import \
    Window, ShapeStim, Circle, TextStim, SimpleImageStim, RatingScale
import pyglet
import json
from socket import gethostname
from cookie_gui import DlgSansCancel

output_path_prefix = argv[1] if len(argv) >= 2 else "results_"
splotch_path_fmt = argv[2] if len(argv) >= 3 else "splotches/%d.png"
condition_permutations_path = argv[3] if len(argv) >= 4 else 'condition-perms.txt'

splotch_total_pixels = 250000
splotch_pixels = {1: {'bad': 37385, 'neutral': 174690, 'good': 37925}, 2: {'bad': 149966, 'neutral': 49810, 'good': 50224}, 3: {'bad': 149780, 'neutral': 50266, 'good': 49954}, 4: {'bad': 112144, 'neutral': 25551, 'good': 112305}, 5: {'bad': 149255, 'neutral': 50927, 'good': 49818}, 6: {'bad': 111848, 'neutral': 25370, 'good': 112782}, 7: {'bad': 50098, 'neutral': 100555, 'good': 99347}, 8: {'bad': 150000, 'neutral': 49967, 'good': 50033}, 9: {'bad': 100374, 'neutral': 49878, 'good': 99748}, 10: {'bad': 37934, 'neutral': 174369, 'good': 37697}, 11: {'bad': 149495, 'neutral': 50313, 'good': 50192}, 12: {'bad': 38295, 'neutral': 174036, 'good': 37669}, 13: {'bad': 75402, 'neutral': 24463, 'good': 150135}, 14: {'bad': 49772, 'neutral': 50617, 'good': 149611}, 15: {'bad': 112498, 'neutral': 25286, 'good': 112216}, 16: {'bad': 37267, 'neutral': 174749, 'good': 37984}, 17: {'bad': 112314, 'neutral': 25618, 'good': 112068}, 18: {'bad': 49872, 'neutral': 50189, 'good': 149939}, 19: {'bad': 112406, 'neutral': 24157, 'good': 113437}, 20: {'bad': 224066, 'neutral': 12456, 'good': 13478}, 21: {'bad': 49721, 'neutral': 49613, 'good': 150666}, 22: {'bad': 149475, 'neutral': 50065, 'good': 50460}, 23: {'bad': 50039, 'neutral': 50786, 'good': 149175}, 24: {'bad': 50723, 'neutral': 49886, 'good': 149391}, 25: {'bad': 112703, 'neutral': 24866, 'good': 112431}, 26: {'bad': 37818, 'neutral': 174544, 'good': 37638}, 27: {'bad': 149837, 'neutral': 24239, 'good': 75924}, 28: {'bad': 50496, 'neutral': 50169, 'good': 149335}, 29: {'bad': 36787, 'neutral': 175052, 'good': 38161}, 30: {'bad': 82667, 'neutral': 82231, 'good': 85102}, 31: {'bad': 50427, 'neutral': 149626, 'good': 49947}, 32: {'bad': 49803, 'neutral': 149665, 'good': 50532}, 33: {'bad': 50697, 'neutral': 149629, 'good': 49674}, 34: {'bad': 50605, 'neutral': 149859, 'good': 49536}, 35: {'bad': 49408, 'neutral': 149920, 'good': 50672}, 36: {'bad': 50376, 'neutral': 149810, 'good': 49814}, 37: {'bad': 50844, 'neutral': 149624, 'good': 49532}, 38: {'bad': 50753, 'neutral': 149172, 'good': 50075}, 39: {'bad': 50102, 'neutral': 149516, 'good': 50382}, 40: {'bad': 50043, 'neutral': 149942, 'good': 50015}}
test_splotches = [
    22, 3, 11,   14, 28, 23,   35, 37, 31,   6, 15, 19,   7, 30]
example_splotch = 20

likert_scale_max = 9
button_radius = .1

# ------------------------------------------------------------
# Helper functions and classes
# ------------------------------------------------------------

def shuffled(l): return sample(l, len(l))

def staggered(l):
    'staggered([1, 2, 3]) → [(1, 2), (2, 3), (3, None)]'
    return zip(l, list(l[1:]) + [None])

def tuplecat(a, b): return (
  b if a is () else
  a if b is () else
 (a if isinstance(a, tuple) else (a,)) +
 (b if isinstance(b, tuple) else (b,)))

data = dict()
def save(key, value):
    """Set a value in data with Perl-style autovivification, so
    save(('times', 3, 'orange'), 'x') is like
    data['times'][3]['orange'] = 'x' but works even if the
    intermediate data structures don't exist yet (or, in the
    case of lists, are too short)."""
    key = tuplecat(tuple(dkey_prefix.p), key)
    if isinstance(key, tuple):
        seq = data
        for k, next_k in staggered(key):
            newobj = (
                 value if next_k is None else
                 [] if isinstance(next_k, int) else
                 {}) # if isinstance(next_k, str)
            if isinstance(seq, dict):
                if k not in seq:
                    seq[k] = newobj
            elif isinstance(seq, list):
                if len(seq) - 1 < k:
                    # The list is too short. Pad it out with Nones.
                    seq[len(seq):] = (k + 1 - len(seq)) * [None]
                if seq[k] is None:
                    seq[k] = newobj
            else: raise KeyError
            seq = seq[k]
    elif isinstance(key, str):
        data[key] = value
    else: raise KeyError

class dkey_prefix:
    p = ()
    def __init__(self, x):
        self.x = x if isinstance(x, tuple) else (x,)
    def __enter__(self):
        dkey_prefix.p = tuplecat(self.x, dkey_prefix.p)
    def __exit__(self, _1, _2, _3): 
        dkey_prefix.p = dkey_prefix.p[len(self.x):]

save(('sys', 'hostname'), gethostname())
save('commit', VERSION)

class timestamps:
   def __init__(self, dkey):
       self.dkey = dkey
   def timestamp(self, i):
       with dkey_prefix('times'): save(tuplecat(self.dkey, i),
           datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S.%f"))
   def __enter__(self):
       self.timestamp(0)
   def __exit__(self, _1, _2, _3):
       self.timestamp(1)

# ------------------------------------------------------------
# Stimuli
# ------------------------------------------------------------

pyglet_screen = pyglet.window.get_platform().get_default_display().get_default_screen()
screen_width, screen_height = pyglet_screen.width, pyglet_screen.height
save(('sys', 'resolution'), (screen_width, screen_height));
approx_dialog_box_width = 200
win = Window((screen_width, screen_height),
    monitor = 'testMonitor',
    winType = 'pyglet', fullscr = False,
    units = 'norm', color = 'white')
mouse = Mouse(win = win)

splotch = SimpleImageStim(win, pos = (0, 125),
    image = splotch_path_fmt % (example_splotch,))

class showing:
    '''"with showing(foo, bar): …" ensures that foo and bar are
    implicitly drawn on each call to draw().'''
    implicitly_draw = []
    def __init__(self, *stimuli):
        self.stimuli = stimuli
    def __enter__(self):
        for s in self.stimuli: showing.implicitly_draw.append(s)
    def __exit__(self, _1, _2, _3):
        for s in self.stimuli: showing.implicitly_draw.remove(s)
def draw(*stimuli):
   for s in stimuli: s.draw()
   for s in showing.implicitly_draw: s.draw()
   win.flip()

def text(x, y, string, hAlign = 'center', vAlign = 'center', wrap = None):
    return TextStim(win,
        text = string, pos = (x, y), color = 'black',
        height = .075, alignHoriz = hAlign, alignVert = vAlign,
        wrapWidth = wrap)

def rect(pos, width, height, color): return ShapeStim(win,
    # "pos" is the upper left-hand corner.
    vertices = (pos, (pos[0] + width, pos[1]),
        (pos[0] + width, pos[1] - height), (pos[0], pos[1] - height)),
    fillColor = color)

def tick(x, y): return ShapeStim(win,
    vertices = ((x, y + .05), (x, y - .05)),
    lineColor = "green", lineWidth = 3)

def rating_scale(stretchHoriz = 1.75, **a): return RatingScale(win,
    textColor = 'black', lineColor = 'black',
    markerStyle = 'circle', markerColor = 'darkgreen',
    stretchHoriz = stretchHoriz,
    showValue = False, allowSkip = False, showScale = False,
    escapeKeys = ['escape'], singleClick = True, showAccept = False,
    **a)

def likert_scale(lo, hi, x = 0, y = -.7): return rating_scale(
    low = 1, lowAnchorText = lo,
    high = likert_scale_max, highAnchorText = hi,
    pos = (x, y))

def probability_scale(x, y, fixed = None):
    args = dict(
        low = 0, high = 1, pos = [x, y], stretchHoriz = 2.5,
        lowAnchorText = 'impossible', highAnchorText = 'certain')
    args['customMarker'] = (
        tick(0, 0) if fixed is None else text(0, 0, ""))
           # The empty text object is invisible.
    rs = rating_scale(**args)
    if fixed is not None:
      # And now we abuse the object system to get rs.draw() to
      # draw a fixed tick mark along with the scale.
        leftmost = min([v[0] for v in rs.line.vertices])
        scale_width = max([v[0] for v in rs.line.vertices]) - leftmost
        tick_x = fixed * scale_width + leftmost
        rs.tick = tick(tick_x, y)
        def f(self):
            rs.tick.draw()
            RatingScale.draw(self)
        rs.draw = MethodType(f, rs, RatingScale)
    # We set the precision beyond the constructor's maximum (100)
    # so the marker can move to any pixel on the scale, but we
    # also override RatingScale.getRating so that the user's
    # choice isn't filtered through the precision and so on.
    rs.precision = 1e20
    def f(self, mouseX):
        self.actual_val = (
            min(max(mouseX, self.lineLeftEnd), self.lineRightEnd) -
            self.lineLeftEnd) / (self.lineRightEnd - self.lineLeftEnd)
        return RatingScale._getMarkerFromPos(self, mouseX)
    rs._getMarkerFromPos = MethodType(f, rs, RatingScale)
    rs.getRating = MethodType(lambda self: self.actual_val, rs, RatingScale)
    return rs

class Button:

    def __init__(self, x, y, string):
        self.x, self.y, self.string, = x, y, string
        self.circle = Circle(win,
            button_radius, pos = (x, y),
            lineColor = 'black', lineWidth = 3, edges = 64,
            fillColor = 'lightgray')
        self.text = text(x, y, string)
        self.was_pressed = False

    def draw(self):
        self.circle.draw()
        self.text.draw()

    def inside(self, (x, y)): return (
        sqrt((self.x - x)*(self.x - x) + (self.y - y)*(self.y - y))
        <= button_radius)

    def activated(self):
        if self.was_pressed or (
                any(mouse.getPressed()) and
                self.inside(mouse.getPos())):
            self.was_pressed = True
            return True
        return False

def scale_screen(dkey, *stimuli):
    """Display some stimuli (including at least one scale) until
    the subject has responded to all the scales."""
    scales = filter(lambda x: isinstance(x, RatingScale), stimuli)
    clearEvents()
    with timestamps(dkey):
        while any([x.noResponse for x in scales]): draw(*stimuli)
    wait(.25)
      # To make the transition less jarring.
    rs = [x.getRating() for x in scales]
    save(dkey, rs[0] if len(rs) == 1 else rs)

def button_screen(dkey, *stimuli):
    """Display some stimuli (including at least one button) until
    the subject presses a button."""
    buttons = filter(lambda x: isinstance(x, Button), stimuli)
    with timestamps(dkey):
        while all([not x.activated() for x in buttons]):
            if getKeys(['escape']): exit()
            clearEvents()
            draw(*stimuli)
    if len(buttons) > 1:
      # No sense in saving the value of the button if there's only
      # one.
        save(dkey, filter(lambda x: x.activated(), buttons)[0].string)
    wait(.25)

def get_string(dkey, prompt,
        dialog_field_label, dialog_hint, dialog_error,
        extractor):
    """Ask for a string with the given prompt. The extractor should
    be a function that translates the user's input into
    whatever should go into 'data' or returns None if the input
    is invalid. dialog_field_label, dialog_hint, and dialog_error
    are strings used in the dialog box."""
    draw(
        text(0, .8, prompt, vAlign = 'top'))
    with timestamps(dkey):
        trying_again = False
        while True:
            dialog = DlgSansCancel(
                title = 'Entry',
                pos = (screen_width/2 - approx_dialog_box_width, .85 * screen_height))
            dialog.addText(' ' * 45)
            dialog.addField(dialog_field_label)
            dialog.addText(dialog_error if trying_again else dialog_hint)
            dialog.show()
            inp = extractor(dialog.data[0])
            if inp is not None:
                save(dkey, inp)
                break
            else:
                trying_again = True
    wait(.25)

def integer_math_problem(dkey, string):
    def extractor(inp):
        mo = match(r'\s*(\d+)\s*$', inp)
        if mo:
            return mo.groups(1)
        return None
    get_string(dkey, string,
        dialog_field_label = 'Your answer:',
        dialog_hint = 'Enter a whole number.',
        dialog_error = "That didn't look like a whole number.",
        extractor = extractor)

def get_amount(dkey, string):
    "Ask for a monetary amount with the given prompt."
    def extractor(inp):
        mo = match(r'\s*\$?\s*(\d+(?:\.\d\d?)?)\s*$', inp)
        if mo:
            return mo.groups(1)[0]
        return None
    get_string(dkey, string,
        dialog_field_label = 'Amount:',
        dialog_hint = 'Enter a dollar amount. Cents are allowed.',
        dialog_error = 'Invalid dollar amount; please try again.',
        extractor = extractor)

def wait_screen(time_to_wait, *stimuli):
    'Display some stimuli for a given amount of time.'
    draw(*stimuli)
    wait(time_to_wait)

def instructions(dkey, string): button_screen(dkey,
    text(0, .8, string, vAlign = 'top'),
    Button(0, -.5, 'Next'))

# ------------------------------------------------------------
# Get the subject number
# ------------------------------------------------------------

while True:
    dialog = Dlg(title = 'Decision-Making')
    dialog.addText('')
    dialog.addField('Subject ID:', 't0')
    dialog.addText('')
    dialog.show()
    if not dialog.OK: exit()
    subject = dialog.data[0]
    mo = search(r'\d+$', subject)
    if mo: break
    message('The subject ID must end with a number.')
save('subject', subject)
condition_index = int(mo.group())

# Assign a condition by using the random numbers in
# condition_permutations_path to pick a permutation of conditions
# and then indexing into the tuple of permutations. This gives
# each subject an equal chance of getting each condition while
# ensuring cell sizes are as close to equal as possible.

possible_conditions = (
   dict(brownie_present = False),
   dict(brownie_present = True))
condition_perms = tuple(permutations(possible_conditions))
with open(condition_permutations_path, "r") as ps:
    condition = (
        condition_perms[int(
                ps.readlines()[condition_index / len(possible_conditions)]
                    .strip())]
            [condition_index % len(possible_conditions)])
brownie_present = condition['brownie_present']
save('brownie_condition',
    'present' if brownie_present else 'absent')

# ------------------------------------------------------------
# Explain the gamble outcomes
# ------------------------------------------------------------

def rating(dkey, string, lo, hi): return scale_screen(dkey,
    text(0, .3, string),
    likert_scale(lo, hi, y = -.3))

with dkey_prefix('outcomes'):

    instructions('first_page', "In this task, you will be asked to evaluate several gambles. If you like, you'll be able to take one of the gambles.\n\nEach gamble has three possible outcomes: good, neutral, and bad.")

    instructions('neutral_description', 'If you get the neutral outcome, nothing happens.')

    instructions(('brownie', 'description'), 'If you get the good outcome, you win a homemade chocolate-caramel brownie!')

    if brownie_present:
        instructions(('brownie', 'look'), "Carefully lift the box on the desk beside you and put it on the floor. You'll find a sample brownie underneath. Don't touch it.")

    rating(('brownie', 'appeal'),
        'How appealing do you find this brownie outcome?',
        'totally unappealing', 'very appealing')

    get_amount(('brownie', 'wtp'), "Now, suppose you played the following game: you would pick an amount of money and then the computer would randomly select a price less than $20. If the randomly selected price was less than or equal to the amount of money you picked, you would be obliged to buy a brownie for the price. But if the price was greater than the amount you picked, you wouldn't be able to buy the brownie even if you wanted to.\n\nWhat amount would you choose?")

    instructions(('arithmetic', 'description'), "If you get the bad outcome, we'll ask you to solve a set of long-division problems, which we expect will take about half an hour.")

    rating(('arithmetic', 'appeal'),
        'How appealing do you find this arithmetic outcome?',
        'totally unappealing', 'very appealing')

    get_amount(('arithmetic', 'wtp'), 'Suppose you played this game: as before, you would pick an amount of money, and then the computer would randomly select a price less than $20. This time, if the randomly selected price was less than or equal to the amount of money you picked, you would have to pay the price without getting anything in return. On the other hand, if the price was greater than the amount you picked, you would have to do the long-division problems.\n\nWhat amount would you choose?')

    rating('neither_appeal',
        'How would you feel if you got neither the brownie outcome nor the math outcome?',
        'very disappointed', 'very relieved')

    button_screen('would_take_both',
        text(0, .3, 'If you were offered a brownie in exchange for doing the division problems, would you take it?'),
        Button(-.25, -.3, 'Yes'),
        Button(.25, -.3, 'No'))

# ------------------------------------------------------------
# Administer a brief measure of temporal discounting
# ------------------------------------------------------------

with dkey_prefix('discount'):

   get_amount('week', "Now suppose you've won a raffle with a cash prize. At your option, you may receive $20 right now or a larger amount of money one week in the future. What is the smallest amount of money that would have to be offered at this future time in order for you to be indifferent between the two options, $20 immediately and the larger amount a week from now?")

   get_amount('month', 'What if the delay was one month instead? Again, what is the smallest amount of money that would have to be offered at this future time in order for you to be indifferent between the two options, $20 immediately and the larger amount a month from now?')

# ------------------------------------------------------------
# Explain the stimuli, with an example
# ------------------------------------------------------------

with showing(splotch):
    def example_gamble_instructions(dkey, string, *stimuli): button_screen(dkey,
        text(-.95, .75, string, hAlign = 'left', vAlign = 'top', wrap = .5),
        Button(0, -.8, 'Next'),
        *stimuli)

    example_gamble_instructions(('picture_explan', 0), "Each of the gambles you'll be asked to evaluate will be presented as a picture like this.")

    example_gamble_instructions(('picture_explan', 1), 'Each color represents the probability of a different outcome. Yellow represents the good outcome (a brownie), black represents the netural outcome (nothing), and blue represents the bad outcome (arithmetic). Each probability is expressed as area.')

    example_gamble_instructions(('picture_explan', 2), "For example, one-twentieth of this image's area is yellow. Thus, the probability of getting the brownie outcome from this gamble is 1 out of 20.")

    with showing(probability_scale(0, -.5, fixed = .05)):
        example_gamble_instructions('mark_example', "You'll provide your judgments of probability using a linear scale like this. In this case, if you were asked the probability of the brownie outcome, you would click on the point marked by the green line.")

        example_gamble_instructions('click_precisely', "Please take your time and CLICK PRECISELY. You'll need to be careful in order to make these judgments accurately.")

instructions('after_prob_judgments', "In addition to these probability judgments, you'll be asked how much each gamble appeals to you and whether, were this gamble offered to you, you would take it.")

instructions('only_one_gamble_counts', "After you've evaluated all of the gambles, one of them will be chosen at random to count for real. If you said you'd take that gamble, you'll get a brownie, arithmetic, or nothing, according to the gamble's probabilites. But if you said you wouldn't take the gamble, you won't have to take it, and nothing more will happen.")

instructions('one_gamble_counting_implies', "Since you can't tell in advance which gamble will count for real, you'll need to decide carefully for all of them.")

instructions('before_gambles', 'Now for the first gamble.')

# ------------------------------------------------------------
# Have the subject evaluate some gambles
# ------------------------------------------------------------

label_x = -.3
scale_1_y = -.45
scale_2_y = -.7
splotches_to_trials = {}

with showing(splotch):
    for trial, splotch_num in enumerate(shuffled(test_splotches)):
        splotch.setImage(splotch_path_fmt % (splotch_num,))
        with dkey_prefix(('gambles', trial)):
            save('splotch', splotch_num)
            splotches_to_trials[splotch_num] = trial
            scale_screen('probs',
                text(-.95, -.2, u'How likely is…', 'left'),
                rect((label_x - .025, scale_1_y - .05), .75, .1,
                    (1, 1, 0)),
                text(label_x, scale_1_y - .1, u'…the brownie outcome?', 'left'),
                probability_scale(0, scale_1_y),
                rect((label_x - .025, scale_2_y - .05), .75, .1,
                    (0, .5, 1)),
                text(label_x, scale_2_y - .1, u'…the math outcome?', 'left'),
                probability_scale(0, scale_2_y))
            scale_screen('appeal',
                text(0, -.5, 'How appealing do you find this gamble?'),
                likert_scale('totally unappealing', 'very appealing'))
            button_screen('choice',
                text(0, -.5, 'If you were offered this gamble, would you take it?'),
                Button(-.25, -.75, 'Yes'),
                Button(.25, -.75, 'No'))

# ------------------------------------------------------------
# Make one gamble count for real
# ------------------------------------------------------------

instructions('before_payout', "Okay, that's all the gambles. I'll now pick one at random to count for real.")

with dkey_prefix('payout'):

    def payout_instructions(dkey, string, *stimuli): button_screen(dkey,
        text(0, -.5, string),
        Button(0, -.8, 'Next'),
        *stimuli)

    splotch_num = choice(test_splotches)
    save('splotch', splotch_num)
    splotch.setImage(splotch_path_fmt % (splotch_num,))

    inflict_bad_outcome = False
    with showing(splotch):
        payout_instructions('picked_gamble', "Here's the gamble I picked.")
        if data['gambles'][ splotches_to_trials[splotch_num] ]['choice'] == 'Yes':
          # The subject said they would take this gamble.
            pixel = randint(1,  splotch_total_pixels)
            save('pixel', pixel)
            sp = splotch_pixels[splotch_num]
            if pixel <= sp['bad']:
                save('outcome', 'arithmetic')
                payout_instructions('got_arithmetic', u'Oh no, you got the arithmetic outcome! Here we go…')
                inflict_bad_outcome = True
            elif pixel - sp['bad'] <= sp['neutral']:
                save('outcome', 'nothing')
                payout_instructions('got_nothing', 'You got the neutral outcome. Nothing happens.')
            else:
                save('outcome', 'brownie')
                payout_instructions('got_brownie', 'You won a brownie! Show this screen to the experimenter in order to claim it.')
        else:
            payout_instructions('you_wimped_out', "You didn't say you'd take this gamble, so you get nothing.")

if inflict_bad_outcome:
    with dkey_prefix('division'):
        integer_math_problem('bad_outcome_p1_9/1', 'What is 9 divided by 1?')
        integer_math_problem('bad_outcome_p2_50/10', 'What is 50 divided by 10?')
        integer_math_problem('bad_outcome_p3_24/8', 'What is 24 divided by 8?')
        #instructions('bad_outcome_done', "Actually, having you do half an hour of division problems would be a waste of your time as well as ours, so let's wrap this up.")

# ------------------------------------------------------------
# Done!
# ------------------------------------------------------------

with open("%s%s.json" % (output_path_prefix, subject), "w") as out:
    json.dump(data, out, sort_keys = True, indent = 2)

wait_screen(1,
    text(0, 0, 'Done!\n\nPlease let the experimenter know you are done.'))
